<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Banana Council — Chimp Judge (Mobile)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    html, body { height: 100%; margin: 0; background:#0f0f12; }
    .wrap {
      width: 100vw; height: 100vh;
      display: grid; place-items: center;
      overflow: hidden;
      touch-action: none; /* we manage scrolling/gestures */
    }
    #game {
      width: 100vw; height: auto;
      max-height: 100vh;
      image-rendering: pixelated;
      border: 2px solid #2a2a33;
      background:#1c1c25;
    }
    /* On-screen buttons */
    .controls {
      position: fixed; left: 0; right: 0; bottom: 0;
      padding: 10px;
      display: flex; justify-content: space-between; gap: 12px;
      pointer-events: none;
    }
    .btn {
      pointer-events: auto;
      user-select: none;
      width: 32vw; max-width: 200px; aspect-ratio: 1.6 / 1;
      background: rgba(0,0,0,0.55);
      border: 2px solid rgba(255,255,255,0.15);
      border-radius: 12px;
      display: grid; place-items: center;
      color: #eaeaf6; font: 18px/1 monospace;
    }
    .btn:active { background: rgba(0,0,0,0.75); }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="136" height="88" aria-label="Chimp Judge"></canvas>

    <div class="controls" aria-hidden="false">
      <div class="btn" id="btn-left">◀</div>
      <div class="btn" id="btn-right">▶</div>
    </div>
  </div>

  <script>
  // ---------- ASSETS (per-frame sequences) ----------
  const ASSETS = {
    bg: 'assets/backgrounds/courtroom.png',
    sfx: 'assets/sfx/fart.wav',
    chimpIdle: (i)=>`assets/characters/chimp/chimp_npc_idle/${i}.png`,  // 0..3
    moleIdle:  (i)=>`assets/characters/mole/mole_npc_idle/${i}.png`,    // 0..3
    judgeIdle: (i)=>`assets/characters/judge/judge_idle/${i}.png`,      // 0..3
    judgeWalk: (i)=>`assets/characters/judge/judge_walk/${i}.png`,      // 0..5
    judgeFart: (i)=>`assets/characters/judge/judge_fart/${i}.png`       // 0..4
  };
  const COUNTS = { chimpIdle:4, moleIdle:4, judgeIdle:4, judgeWalk:6, judgeFart:5 };

  // ---------- Canvas / world ----------
  const FRAME_W = 64, FRAME_H = 64;
  const SPRITE_SCALE = 0.75;            // smaller characters
  const SPEED = 0.14;                    // pixels per ms (slow walk across)
  const PROMPT_RADIUS = 16;              // when close enough to show nameplate
  const FART_MS = 350;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let GROUND_Y = canvas.height - 1;

  // ---------- Input ----------
  const hold = { left:false, right:false };
  function bindHold(el, key){
    const on = ()=>hold[key]=true, off=()=>hold[key]=false;
    el.addEventListener('touchstart', (e)=>{on(); e.preventDefault();}, {passive:false});
    el.addEventListener('touchend',   (e)=>{off(); e.preventDefault();}, {passive:false});
    el.addEventListener('touchcancel',(e)=>{off(); e.preventDefault();}, {passive:false});
    el.addEventListener('mousedown',  (e)=>{on(); e.preventDefault();});
    el.addEventListener('mouseup',    (e)=>{off(); e.preventDefault();});
    el.addEventListener('mouseleave', ()=>{off();});
  }
  bindHold(document.getElementById('btn-left'), 'left');
  bindHold(document.getElementById('btn-right'),'right');

  canvas.addEventListener('touchstart', handleTap, {passive:false});
  canvas.addEventListener('mousedown',  (e)=>handleTap(mouseToCanvas(e)));
  function mouseToCanvas(e){
    const r=canvas.getBoundingClientRect();
    const sx=canvas.width/r.width, sy=canvas.height/r.height;
    return {clientX:e.clientX, clientY:e.clientY, _sx:sx, _sy:sy, _rect:r};
  }
  function handleTap(e){
    const t = e.changedTouches ? e.changedTouches[0] : e;
    const rect = t._rect || canvas.getBoundingClientRect();
    const sx   = t._sx   || (canvas.width/rect.width);
    const sy   = t._sy   || (canvas.height/rect.height);
    const cx = (t.clientX - rect.left) * sx;
    const cy = (t.clientY - rect.top)  * sy;
    tryInteract(cx, cy);
    if (e.preventDefault) e.preventDefault();
  }

  // ---------- Loaders ----------
  function loadImage(src){
    return new Promise(res=>{
      const img=new Image();
      img.onload=()=>res(img);
      img.onerror=()=>res(null);
      img.src=src;
    });
  }
  async function loadSeq(builder, count){
    const out=[];
    for(let i=0;i<count;i++) out.push(await loadImage(builder(i)));
    return out.every(Boolean) ? out : null;
  }
  function loadAudio(src){
    try{ return new Audio(src); }catch(_){ return null; }
  }

  const Images = {
    bg:null,
    chimpIdle:null, moleIdle:null,
    judgeIdle:null, judgeWalk:null, judgeFart:null
  };
  let fartAudio = loadAudio(ASSETS.sfx);

  (async function preload(){
    Images.bg = await loadImage(ASSETS.bg);
    if (Images.bg){
      canvas.width  = Images.bg.naturalWidth  || Images.bg.width;
      canvas.height = Images.bg.naturalHeight || Images.bg.height;
      GROUND_Y = canvas.height - 1;
      placeEntities();
    }
    Images.chimpIdle = await loadSeq(ASSETS.chimpIdle, COUNTS.chimpIdle);
    Images.moleIdle  = await loadSeq(ASSETS.moleIdle,  COUNTS.moleIdle);
    Images.judgeIdle = await loadSeq(ASSETS.judgeIdle, COUNTS.judgeIdle);
    Images.judgeWalk = await loadSeq(ASSETS.judgeWalk, COUNTS.judgeWalk);
    Images.judgeFart = await loadSeq(ASSETS.judgeFart, COUNTS.judgeFart);
    requestAnimationFrame(loop);
  })();

  // ---------- Entities ----------
  const player = { x: 0, y: 0, facing: 1, state:'idle', until:0, anim:0 };
  const chimp  = { x: 0, y: 0, anim:0, label:'James Coyne' };
  const mole   = { x: 0, y: 0, anim:0, label:'James Holland' };

  function placeEntities(){
    // keep NPCs just inside the edges
    const dw = Math.round(FRAME_W * SPRITE_SCALE);
    const margin = Math.max(6, Math.floor(dw/2) + 2);
    chimp.x = margin;            chimp.y = GROUND_Y;
    mole.x  = canvas.width - margin; mole.y  = GROUND_Y;
    player.x = canvas.width / 2; player.y = GROUND_Y;
  }

  function distX(a,b){ return Math.abs(a.x - b.x); }
  function facingToward(from, to){ return (to.x < from.x) ? -1 : 1; }

  // ---------- Draw helpers (scaled) ----------
  function drawFrame(img, x, y, facing){
    if (!img) return;
    const dw = Math.round(FRAME_W * SPRITE_SCALE);
    const dh = Math.round(FRAME_H * SPRITE_SCALE);
    ctx.save();
    if (facing === -1){ ctx.translate(x,0); ctx.scale(-1,1); x = 0; }
    ctx.drawImage(img, x - dw/2, y - dh, dw, dh);
    ctx.restore();
  }
  function drawSeq(seq, tms, x, y, facing, msPerFrame){
    if (!seq) return;
    const idx = Math.floor((tms / msPerFrame) % seq.length);
    drawFrame(seq[idx], x, y, facing);
  }

  // ---------- Nameplate (small; shown only for active NPC) ----------
  function drawNamePlate(x, y, text){
    const dh = Math.round(FRAME_H * SPRITE_SCALE);
    const w = Math.max(60, text.length * 6.2);
    const h = 14;
    const top = y - dh - 6;
    ctx.fillStyle = 'rgba(255,255,255,0.98)';
    ctx.fillRect(x - w/2, top - h, w, h);
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.strokeRect(x - w/2, top - h, w, h);
    ctx.fillStyle = '#111';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(text, x, top - 3);
  }

  // ---------- Loop ----------
  let last = 0;
  function loop(ts){
    const dt = (ts - last) || 16.67; last = ts;

    if (player.state !== 'fart'){
      if (hold.left && !hold.right){ player.x -= SPEED*dt; player.facing = -1; player.state = 'walk'; }
      else if (hold.right && !hold.left){ player.x += SPEED*dt; player.facing = 1; player.state = 'walk'; }
      else { player.state = 'idle'; }
    }

    // keep the player inside the scene
    const half = Math.round((FRAME_W * SPRITE_SCALE) / 2);
    player.x = Math.max(half, Math.min(canvas.width - half, player.x));

    if (player.state === 'fart' && performance.now() > player.until){ player.state = 'idle'; }

    player.anim += dt; chimp.anim += dt; mole.anim += dt;

    render();
    requestAnimationFrame(loop);
  }

  function render(){
    // background
    if (Images.bg) ctx.drawImage(Images.bg, 0, 0, canvas.width, canvas.height);
    else { ctx.fillStyle = '#1d1f29'; ctx.fillRect(0,0,canvas.width,canvas.height); }

    // NPCs
    if (Images.chimpIdle) drawSeq(Images.chimpIdle, chimp.anim, chimp.x, chimp.y, 1, 140);
    if (Images.moleIdle)  drawSeq(Images.moleIdle,  mole.anim,  mole.x,  mole.y, 1, 140);

    // Player
    if (player.state === 'walk' && Images.judgeWalk){
      drawSeq(Images.judgeWalk, player.anim, player.x, player.y, player.facing, 120);
    } else if (player.state === 'fart' && Images.judgeFart){
      drawSeq(Images.judgeFart, player.anim, player.x, player.y, player.facing, 90);
    } else if (Images.judgeIdle){
      drawSeq(Images.judgeIdle, player.anim, player.x, player.y, player.facing, 140);
    } else {
      // fallback placeholder
      ctx.fillStyle = '#8338EC'; ctx.fillRect(player.x-22, player.y-60, 44, 60);
      ctx.fillStyle = '#e7e7e7'; ctx.fillRect(player.x-22, player.y-66, 44, 6);
    }

    // Context nameplate: only for the nearest NPC within range
    const active = closestInRange();
    if (active === chimp)  drawNamePlate(chimp.x, chimp.y, chimp.label);
    if (active === mole)   drawNamePlate(mole.x,  mole.y,  mole.label);
  }

  function closestInRange(){
    const near = [];
    if (Math.abs(player.x - chimp.x) <= PROMPT_RADIUS) near.push(chimp);
    if (Math.abs(player.x - mole.x)  <= PROMPT_RADIUS) near.push(mole);
    if (!near.length) return null;
    return near.reduce((a,b)=> Math.abs(player.x-a.x) < Math.abs(player.x-b.x) ? a : b);
  }

  // ---------- Interaction ----------
  function tryInteract(cx, cy){
    const target = closestInRange();
    if (!target) return;

    const halfW = Math.round((FRAME_W * SPRITE_SCALE) / 2);
    const topY  = GROUND_Y - Math.round(FRAME_H * SPRITE_SCALE);
    const within =
      (cx >= target.x - halfW) && (cx <= target.x + halfW) &&
      (cy >= topY) && (cy <= GROUND_Y);

    if (!within) return;

    player.facing = facingToward(player, target);
    player.state = 'fart';
    player.until = performance.now() + FART_MS;
    player.anim = 0;
    if (fartAudio){ try { fartAudio.currentTime = 0; fartAudio.play(); } catch(_){} }
  }
  </script>
</body>
</html>
