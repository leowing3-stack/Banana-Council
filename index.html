<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Banana Council — Chimp Judge (Mobile)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    :root { --safe-bot: env(safe-area-inset-bottom, 0px); }
    html, body { height: 100%; margin: 0; background:#0f0f12; }
    .wrap {
      width: 100vw; height: 100vh;
      display: grid; place-items: center;
      overflow: hidden;
      touch-action: none; /* prevent browser gestures */
    }
    #game {
      width: 100vw; height: auto;      /* scale to phone width */
      max-height: 100vh;
      image-rendering: pixelated;
      border: 2px solid #2a2a33;
      background:#1c1c25;
    }
    /* On-screen buttons */
    .controls {
      position: fixed; left: 0; right: 0; bottom: 0;
      padding: calc(10px + var(--safe-bot));
      display: flex; justify-content: space-between; gap: 12px;
      pointer-events: none; /* children re-enable */
    }
    .btn {
      pointer-events: auto;
      user-select: none;
      width: 32vw; max-width: 200px; aspect-ratio: 1.6 / 1;
      background: rgba(0,0,0,0.55);
      border: 2px solid rgba(255,255,255,0.15);
      border-radius: 12px;
      display: grid; place-items: center;
      color: #eaeaf6; font: 18px/1 monospace;
    }
    .btn:active { background: rgba(0,0,0,0.75); }
    .hint {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: calc(70px + var(--safe-bot));
      background: rgba(0,0,0,0.6);
      color: #cfcfe7; font: 12px monospace; padding: 6px 8px; border-radius: 6px;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="136" height="88" aria-label="Chimp Judge"></canvas>

    <div class="hint">Hold ◀ ▶ to walk • When close, <b>tap the NPC</b> to fart.</div>

    <div class="controls" aria-hidden="false">
      <div class="btn" id="btn-left">◀</div>
      <div class="btn" id="btn-right">▶</div>
    </div>
  </div>

  <script>
  // -------------------- ASSET MAP (per-frame images) -------------------------
  const ASSETS = {
    bg: 'assets/backgrounds/courtroom.png',
    sfx: 'assets/sfx/fart.wav',
    chimpIdle: (i)=>`assets/characters/chimp/chimp_npc_idle/${i}.png`,   // 0..3
    moleIdle:  (i)=>`assets/characters/mole/mole_npc_idle/${i}.png`,     // 0..3
    judgeIdle: (i)=>`assets/characters/judge_idle/${i}.png`,             // 0..3
    judgeWalk: (i)=>`assets/characters/judge_walk/${i}.png`,             // 0..5
    judgeFart: (i)=>`assets/characters/judge_fart/${i}.png`              // 0..4
  };
  const COUNTS = { chimpIdle:4, moleIdle:4, judgeIdle:4, judgeWalk:6, judgeFart:5 };

  // Recommended sprite frame size
  const FRAME_W = 64, FRAME_H = 64;

  // -------------------- Canvas / sizing -------------------------------------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Ground = bottom of the background image; set after bg loads.
  let GROUND_Y = canvas.height - 1;

  // Movement / gameplay tuning (background is small; values are in bg pixels/ms)
  const SPEED = 0.5;              // walk speed
  const PROMPT_RADIUS = 14;       // distance to show "tap" prompt
  const FART_MS = 350;

  // -------------------- Input (touch + mouse) -------------------------------
  const hold = { left:false, right:false };
  function bindHold(el, key){
    const on = ()=>hold[key]=true, off=()=>hold[key]=false;
    el.addEventListener('touchstart', (e)=>{on(); e.preventDefault();}, {passive:false});
    el.addEventListener('touchend',   (e)=>{off(); e.preventDefault();}, {passive:false});
    el.addEventListener('touchcancel',(e)=>{off(); e.preventDefault();}, {passive:false});
    el.addEventListener('mousedown',  (e)=>{on(); e.preventDefault();});
    el.addEventListener('mouseup',    (e)=>{off(); e.preventDefault();});
    el.addEventListener('mouseleave', (e)=>{off();});
  }
  bindHold(document.getElementById('btn-left'), 'left');
  bindHold(document.getElementById('btn-right'),'right');

  // Tap on canvas to interact with NPC in range
  canvas.addEventListener('touchstart', handleTap, {passive:false});
  canvas.addEventListener('mousedown',  (e)=>handleTap(mouseToCanvas(e)));

  function mouseToCanvas(e){
    const r=canvas.getBoundingClientRect();
    const sx=canvas.width/r.width, sy=canvas.height/r.height;
    return {clientX:e.clientX, clientY:e.clientY, _sx:sx, _sy:sy, _rect:r};
  }
  function handleTap(e){
    const t = e.changedTouches ? e.changedTouches[0] : e;
    const rect = t._rect || canvas.getBoundingClientRect();
    const sx   = t._sx   || (canvas.width/rect.width);
    const sy   = t._sy   || (canvas.height/rect.height);
    const cx = (t.clientX - rect.left) * sx;
    const cy = (t.clientY - rect.top)  * sy;
    tryInteract(cx, cy);
    if (e.preventDefault) e.preventDefault();
  }

  // -------------------- Loaders ---------------------------------------------
  function loadImage(src){
    return new Promise(res=>{
      const img=new Image();
      img.onload=()=>res(img);
      img.onerror=()=>res(null);
      img.src=src;
    });
  }
  async function loadSeq(builder, count){
    const out=[];
    for(let i=0;i<count;i++) out.push(await loadImage(builder(i)));
    return out.every(Boolean) ? out : null;
  }
  function loadAudio(src){
    try{ return new Audio(src); }catch(_){ return null; }
  }

  const Images = {
    bg:null,
    chimpIdle:null,   // frame arrays
    moleIdle:null,
    judgeIdle:null,
    judgeWalk:null,
    judgeFart:null
  };
  let fartAudio = loadAudio(ASSETS.sfx);

  (async function preload(){
    Images.bg = await loadImage(ASSETS.bg);
    if (Images.bg){
      canvas.width  = Images.bg.naturalWidth  || Images.bg.width;
      canvas.height = Images.bg.naturalHeight || Images.bg.height;
      GROUND_Y = canvas.height - 1;
    }
    Images.chimpIdle = await loadSeq(ASSETS.chimpIdle, COUNTS.chimpIdle);
    Images.moleIdle  = await loadSeq(ASSETS.moleIdle,  COUNTS.moleIdle);
    Images.judgeIdle = await loadSeq(ASSETS.judgeIdle, COUNTS.judgeIdle);
    Images.judgeWalk = await loadSeq(ASSETS.judgeWalk, COUNTS.judgeWalk);
    Images.judgeFart = await loadSeq(ASSETS.judgeFart, COUNTS.judgeFart);
    requestAnimationFrame(loop);
  })();

  // -------------------- Entities --------------------------------------------
  const player = { x: 0, y: 0, facing: 1, state:'idle', until:0, anim:0, w:FRAME_W, h:FRAME_H };
  const chimp  = { x: 0, y: 0, anim:0, w:FRAME_W, h:FRAME_H };
  const mole   = { x: 0, y: 0, anim:0, w:FRAME_W, h:FRAME_H };

  // place them after bg sizing
  function placeEntities(){
    player.x = canvas.width/2; player.y = GROUND_Y;
    chimp.x  = Math.max(20, canvas.width*0.25);  chimp.y = GROUND_Y;
    mole.x   = Math.min(canvas.width-20, canvas.width*0.75);  mole.y = GROUND_Y;
  }
  placeEntities();

  function distX(a,b){ return Math.abs(a.x - b.x); }
  function facingToward(from, to){ return (to.x < from.x) ? -1 : 1; }

  // -------------------- Animation helpers -----------------------------------
  function drawFrame(img, x, y, facing){
    if (!img) return;
    ctx.save();
    if (facing === -1){
      ctx.translate(x,0); ctx.scale(-1,1); x = 0;
    }
    ctx.drawImage(img, x - FRAME_W/2, y - FRAME_H, FRAME_W, FRAME_H);
    ctx.restore();
  }
  function drawSeq(seq, tms, x, y, facing, msPerFrame){
    if (!seq) return;
    const idx = Math.floor((tms / msPerFrame) % seq.length);
    drawFrame(seq[idx], x, y, facing);
  }

  // -------------------- Game loop -------------------------------------------
  let last = 0;
  function loop(ts){
    const dt = (ts - last) || 16.67; last = ts;

    // Movement (hold ◀▶ to walk), unless farting
    if (player.state !== 'fart'){
      if (hold.left && !hold.right){ player.x -= SPEED*dt; player.facing = -1; player.state = 'walk'; }
      else if (hold.right && !hold.left){ player.x += SPEED*dt; player.facing = 1; player.state = 'walk'; }
      else { player.state = 'idle'; }
    }

    // Bounds
    const margin = FRAME_W*0.4;
    player.x = Math.max(margin, Math.min(canvas.width - margin, player.x));

    // End fart
    if (player.state === 'fart' && performance.now() > player.until){ player.state = 'idle'; }

    // Anim clocks
    player.anim += dt; chimp.anim += dt; mole.anim += dt;

    render();
    requestAnimationFrame(loop);
  }

  function render(){
    // Background
    if (Images.bg) ctx.drawImage(Images.bg, 0, 0, canvas.width, canvas.height);
    else { ctx.fillStyle = '#1d1f29'; ctx.fillRect(0,0,canvas.width,canvas.height); }

    // NPCs (idle)
    if (Images.chimpIdle) drawSeq(Images.chimpIdle, chimp.anim, chimp.x, chimp.y, 1, 140);
    else { ctx.fillStyle = '#5ab'; ctx.fillRect(chimp.x-22, chimp.y-48, 44, 48); }

    if (Images.moleIdle) drawSeq(Images.moleIdle, mole.anim, mole.x, mole.y, 1, 140);
    else { ctx.fillStyle = '#b85'; ctx.fillRect(mole.x-22, mole.y-48, 44, 48); }

    // Player (idle/walk/fart). Fart animation is LEFT set; RIGHT is mirrored via facing.
    if (player.state === 'walk' && Images.judgeWalk){
      drawSeq(Images.judgeWalk, player.anim, player.x, player.y, player.facing, 110);
    } else if (player.state === 'fart' && Images.judgeFart){
      drawSeq(Images.judgeFart, player.anim, player.x, player.y, player.facing, 90);
    } else if (Images.judgeIdle){
      drawSeq(Images.judgeIdle, player.anim, player.x, player.y, player.facing, 140);
    } else {
      // Placeholder
      ctx.fillStyle = '#8338EC'; ctx.fillRect(player.x-22, player.y-60, 44, 60);
      ctx.fillStyle = '#e7e7e7'; ctx.fillRect(player.x-22, player.y-66, 44, 6);
    }

    // Prompt if close
    const target = closestInRange();
    if (target) drawPrompt(target.x, target.y - FRAME_H - 6, 'Tap');
  }

  function drawPrompt(x, y, text){
    const w = 40, h = 16;
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.fillRect(x - w/2, y - h, w, h);
    ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.strokeRect(x - w/2, y - h, w, h);
    ctx.fillStyle = '#111'; ctx.font = '10px monospace'; ctx.textAlign = 'center';
    ctx.fillText(text, x, y - 4);
  }

  function closestInRange(){
    const near = [];
    if (Math.abs(player.x - chimp.x) <= PROMPT_RADIUS) near.push(chimp);
    if (Math.abs(player.x - mole.x)  <= PROMPT_RADIUS) near.push(mole);
    if (!near.length) return null;
    return near.reduce((a,b)=> Math.abs(player.x-a.x) < Math.abs(player.x-b.x) ? a : b);
  }

  // -------------------- Interaction -----------------------------------------
  function tryInteract(cx, cy){
    const target = closestInRange();
    if (!target) return;

    // Hit test (frame bounds)
    const halfW = FRAME_W/2, topY = target.y - FRAME_H, bottomY = target.y;
    const within =
      (cx >= target.x - halfW) && (cx <= target.x + halfW) &&
      (cy >= topY) && (cy <= bottomY);

    if (!within) return;

    // Trigger fart (mirror by facing toward target)
    player.facing = facingToward(player, target);
    player.state = 'fart';
    player.until = performance.now() + FART_MS;
    player.anim = 0;
    if (fartAudio){ try { fartAudio.currentTime = 0; fartAudio.play(); } catch(_){} }
  }
  </script>
</body>
</html>
