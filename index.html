<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Banana Council — Chimp Judge (Mobile)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    html, body { height: 100%; margin: 0; background:#0f0f12; }
    .wrap {
      width: 100vw; height: 100vh;
      display: grid; place-items: center;
      overflow: hidden;
      touch-action: none;
      position: relative;
    }
    #game {
      width: 100vw; height: auto;
      max-height: 100vh;
      image-rendering: pixelated;
      border: 2px solid #2a2a33;
      background:#1c1c25;
      display:block;
    }
    .controls {
      position: fixed; left: 0; right: 0; bottom: 0;
      padding: 10px;
      display: flex; justify-content: space-between; gap: 12px;
      pointer-events: none;
    }
    .btn {
      pointer-events: auto;
      user-select: none;
      width: 32vw; max-width: 200px; aspect-ratio: 1.6 / 1;
      background: rgba(0,0,0,0.55);
      border: 2px solid rgba(255,255,255,0.15);
      border-radius: 12px;
      display: grid; place-items: center;
      color: #eaeaf6; font: 18px/1 monospace;
    }
    .btn:active { background: rgba(0,0,0,0.75); }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="136" height="88" aria-label="Chimp Judge"></canvas>

    <div class="controls" aria-hidden="false">
      <div class="btn" id="btn-left">◀</div>
      <div class="btn" id="btn-right">▶</div>
    </div>
  </div>

  <script>
  // ---- ASSETS (per-frame images) ----
  const ASSETS = {
    bg: 'assets/backgrounds/courtroom.png',
    sfx: 'assets/sfx/fart.wav',
    chimpIdle: (i)=>`assets/characters/chimp/chimp_npc_idle/${i}.png`,  // 0..3
    moleIdle:  (i)=>`assets/characters/mole/mole_npc_idle/${i}.png`,    // 0..3
    judgeIdle: (i)=>`assets/characters/judge/judge_idle/${i}.png`,      // 0..3
    judgeWalk: (i)=>`assets/characters/judge/judge_walk/${i}.png`,      // 0..5
    judgeFart: (i)=>`assets/characters/judge/judge_fart/${i}.png`       // 0..4
  };
  const COUNTS = { chimpIdle:4, moleIdle:4, judgeIdle:4, judgeWalk:6, judgeFart:5 };

  // ---- World / sizing ----
  const FRAME_W = 64, FRAME_H = 64;
  const SPRITE_SCALE = 0.70;         // smaller characters
  const SPEED = 0.09;                // slow walk (px/ms)
  const PROMPT_RADIUS = 18;          // when close enough to show name
  const FART_FALLBACK_MS = 1200;     // backup if audio end event fails

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });
  let GROUND_Y = canvas.height - 1;

  // ---- Input ----
  const hold = { left:false, right:false };
  function bindHold(el, key){
    const on = ()=>hold[key]=true, off=()=>hold[key]=false;
    el.addEventListener('touchstart', (e)=>{on(); e.preventDefault();}, {passive:false});
    el.addEventListener('touchend',   (e)=>{off(); e.preventDefault();}, {passive:false});
    el.addEventListener('touchcancel',(e)=>{off(); e.preventDefault();}, {passive:false});
    el.addEventListener('mousedown',  (e)=>{on(); e.preventDefault();});
    el.addEventListener('mouseup',    (e)=>{off(); e.preventDefault();});
    el.addEventListener('mouseleave', ()=>{off();});
  }
  bindHold(document.getElementById('btn-left'), 'left');
  bindHold(document.getElementById('btn-right'),'right');

  canvas.addEventListener('touchstart', handleTap, {passive:false});
  canvas.addEventListener('mousedown',  (e)=>handleTap(mouseToCanvas(e)));
  function mouseToCanvas(e){
    const r=canvas.getBoundingClientRect();
    const sx=canvas.width/r.width, sy=canvas.height/r.height;
    return {clientX:e.clientX, clientY:e.clientY, _sx:sx, _sy:sy, _rect:r};
  }
  function handleTap(e){
    const t = e.changedTouches ? e.changedTouches[0] : e;
    const rect = t._rect || canvas.getBoundingClientRect();
    const sx   = t._sx   || (canvas.width/rect.width);
    const sy   = t._sy   || (canvas.height/rect.height);
    const cx = (t.clientX - rect.left) * sx;
    const cy = (t.clientY - rect.top)  * sy;
    tryInteract(cx, cy);
    if (e.preventDefault) e.preventDefault();
  }

  // ---- Loaders ----
  function loadImage(src){
    return new Promise(res=>{
      const img=new Image();
      img.onload=()=>res(img);
      img.onerror=()=>res(null);
      img.src=src;
    });
  }
  async function loadSeq(builder, count){
    const out=[];
    for(let i=0;i<count;i++) out.push(await loadImage(builder(i)));
    return out.every(Boolean) ? out : null;
  }
  function makeAudio(src){
    try{ return new Audio(src); }catch(_){ return null; }
  }

  const Images = {
    bg:null,
    chimpIdle:null, moleIdle:null,
    judgeIdle:null, judgeWalk:null, judgeFart:null
  };
  let fartAudio = null;

  // ---- Entities ----
  const player = { x: 0, y: 0, facing: 1, state:'idle', anim:0, fartTimer:null };
  const chimp  = { x: 0, y: 0, anim:0, label:'Coyne'   };
  const mole   = { x: 0, y: 0, anim:0, label:'Holland' };

  function placeEntities(){
    const half = Math.round((FRAME_W * SPRITE_SCALE) / 2);
    const margin = Math.max(2, half + 1);
    chimp.x = margin;                chimp.y = GROUND_Y;
    mole.x  = canvas.width - margin; mole.y  = GROUND_Y;
    player.x = Math.floor(canvas.width / 2); player.y = GROUND_Y;
  }

  function facingToward(from, to){ return (to.x < from.x) ? -1 : 1; }

  // ---- Draw helpers (scaled) ----
  function drawFrame(img, x, y, facing){
    if (!img) return;
    const dw = Math.round(FRAME_W * SPRITE_SCALE);
    const dh = Math.round(FRAME_H * SPRITE_SCALE);
    ctx.save();
    if (facing === -1){ ctx.translate(x,0); ctx.scale(-1,1); x = 0; }
    ctx.drawImage(img, x - dw/2, y - dh, dw, dh);
    ctx.restore();
  }
  function drawSeq(seq, tms, x, y, facing, msPerFrame){
    if (!seq) return;
    const idx = Math.floor((tms / msPerFrame) % seq.length);
    drawFrame(seq[idx], x, y, facing);
  }

  // ---- Labels ----
  function drawNamePlate(x, y, text){
    const dh = Math.round(FRAME_H * SPRITE_SCALE);
    const w = Math.max(44, Math.ceil(text.length * 6));
    const h = 12;
    const top = y - dh - 5;
    ctx.fillStyle = 'rgba(255,255,255,0.98)';
    ctx.fillRect(x - w/2, top - h, w, h);
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.strokeRect(x - w/2, top - h, w, h);
    ctx.fillStyle = '#111';
    ctx.font = '9px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(text, x, top - 3);
  }
  function drawTinyTagBelow(x, y, text){
    const w = Math.max(30, Math.ceil(text.length * 5.5));
    const h = 10;
    const base = y + 4;
    ctx.fillStyle = 'rgba(255,255,255,0.98)';
    ctx.fillRect(x - w/2, base, w, h);
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.strokeRect(x - w/2, base, w, h);
    ctx.fillStyle = '#111';
    ctx.font = '8px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(text, x, base + h - 3);
  }

  // ---- Preload immediately (no start screen) ----
  (async function preloadImmediate(){
    fartAudio = makeAudio(ASSETS.sfx);

    Images.bg = await loadImage(ASSETS.bg);
    if (Images.bg){
      canvas.width  = Images.bg.naturalWidth  || Images.bg.width;
      canvas.height = Images.bg.naturalHeight || Images.bg.height;
      GROUND_Y = canvas.height - 1;
      placeEntities();
    }

    [Images.chimpIdle, Images.moleIdle, Images.judgeIdle, Images.judgeWalk, Images.judgeFart] =
      await Promise.all([
        loadSeq(ASSETS.chimpIdle, COUNTS.chimpIdle),
        loadSeq(ASSETS.moleIdle,  COUNTS.moleIdle),
        loadSeq(ASSETS.judgeIdle, COUNTS.judgeIdle),
        loadSeq(ASSETS.judgeWalk, COUNTS.judgeWalk),
        loadSeq(ASSETS.judgeFart, COUNTS.judgeFart)
      ]);

    requestAnimationFrame(loop);
  })();

  // ---- Loop ----
  let last = 0;
  function loop(ts){
    const dt = (ts - last) || 16.67; last = ts;

    if (player.state !== 'fart'){
      if (hold.left && !hold.right){ player.x -= SPEED*dt; player.facing = -1; player.state = 'walk'; }
      else if (hold.right && !hold.left){ player.x += SPEED*dt; player.facing = 1; player.state = 'walk'; }
      else { player.state = 'idle'; }
    }

    const half = Math.round((FRAME_W * SPRITE_SCALE) / 2);
    player.x = Math.max(half, Math.min(canvas.width - half, player.x));

    player.anim += dt; chimp.anim += dt; mole.anim += dt;

    render();
    requestAnimationFrame(loop);
  }

  function render(){
    if (Images.bg) ctx.drawImage(Images.bg, 0, 0, canvas.width, canvas.height);
    else { ctx.fillStyle = '#1d1f29'; ctx.fillRect(0,0,canvas.width,canvas.height); }

    if (Images.chimpIdle) drawSeq(Images.chimpIdle, chimp.anim, chimp.x, chimp.y, 1, 140);
    if (Images.moleIdle)  drawSeq(Images.moleIdle,  mole.anim,  mole.x,  mole.y, 1, 140);

    if (player.state === 'walk' && Images.judgeWalk){
      drawSeq(Images.judgeWalk, player.anim, player.x, player.y, player.facing, 120);
    } else if (player.state === 'fart' && Images.judgeFart){
      drawSeq(Images.judgeFart, player.anim, player.x, player.y, player.facing, 90);
    } else if (Images.judgeIdle){
      drawSeq(Images.judgeIdle, player.anim, player.x, player.y, player.facing, 140);
    } else {
      ctx.fillStyle = '#8338EC'; ctx.fillRect(player.x-22, player.y-60, 44, 60);
      ctx.fillStyle = '#e7e7e7'; ctx.fillRect(player.x-22, player.y-66, 44, 6);
    }

    const active = closestInRange();
    if (active === chimp)  drawNamePlate(chimp.x, chimp.y, chimp.label);
    if (active === mole)   drawNamePlate(mole.x,  mole.y,  mole.label);

    // tiny “Leo” under the judge (always)
    drawTinyTagBelow(player.x, player.y, 'Leo');
  }

  function closestInRange(){
    const near = [];
    if (Math.abs(player.x - chimp.x) <= PROMPT_RADIUS) near.push(chimp);
    if (Math.abs(player.x - mole.x)  <= PROMPT_RADIUS) near.push(mole);
    if (!near.length) return null;
    return near.reduce((a,b)=> Math.abs(player.x-a.x) < Math.abs(player.x-b.x) ? a : b);
  }

  // ---- Interaction ----
  function tryInteract(cx, cy){
    const target = closestInRange();
    if (!target) return;

    const halfW = Math.round((FRAME_W * SPRITE_SCALE) / 2);
    const topY  = GROUND_Y - Math.round(FRAME_H * SPRITE_SCALE);
    const within =
      (cx >= target.x - halfW) && (cx <= target.x + halfW) &&
      (cy >= topY) && (cy <= GROUND_Y);

    if (!within) return;

    // Face the opposite direction when farting (left walk → face right, etc.)
    player.facing = -player.facing;
    player.state = 'fart';
    player.anim = 0;

    let ended = false;
    const endFart = ()=>{
      if (ended) return;
      ended = true;
      player.state = 'idle';
      if (player.fartTimer){ clearTimeout(player.fartTimer); player.fartTimer = null; }
      if (fartAudio){ fartAudio.onended = null; }
    };

    if (fartAudio){
      try {
        fartAudio.currentTime = 0;
        fartAudio.onended = endFart;
        const p = fartAudio.play();
        if (p && p.catch) p.catch(()=>{});
      } catch(_) {}
    }
    player.fartTimer = setTimeout(endFart, FART_FALLBACK_MS);
  }
  </script>
</body>
</html>
