
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Chimp Judge — Mobile</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    :root { --ui-safe: env(safe-area-inset-bottom, 0px); }
    html, body { height: 100%; margin: 0; background:#0f0f12; }
    /* Center the game; canvas scales to device width while preserving the background's aspect */
    .wrap {
      width: 100vw; height: 100vh;
      display: grid; place-items: center;
      overflow: hidden;
      touch-action: none; /* we manage touch */
    }
    #game {
      image-rendering: pixelated;  /* crispy pixels */
      image-rendering: crisp-edges;
      width: 100vw; height: auto;  /* scale to screen width */
      max-height: 100vh;
      border: 2px solid #2a2a33;
      background: #1c1c25;
    }
    /* Touch zones: left / right movers stacked over the canvas */
    .controls {
      position: fixed; inset: 0; pointer-events: none; /* let taps pass unless we enable */
    }
    .zone {
      position: absolute; top: 0; bottom: 0; width: 34%;
      pointer-events: auto; /* active for touch */
    }
    .zone.left  { left: 0; }
    .zone.right { right: 0; }
    /* Middle zone isn’t needed—tap directly on the NPC to fart */

    /* Minimal mobile hint */
    .hint {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: calc(8px + var(--ui-safe));
      background: rgba(0,0,0,0.6);
      color: #cfcfe7; font: 12px/1.2 monospace; padding: 6px 8px; border-radius: 6px;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="136" height="88" aria-label="Chimp Judge Game"></canvas>
    <!-- Full-screen control overlay -->
    <div class="controls" aria-hidden="true">
      <div class="zone left"></div>
      <div class="zone right"></div>
    </div>
    <div class="hint">Hold left/right side to walk • When close, <b>tap the character</b> to… uh… administer justice.</div>
  </div>

  <script>
  // ====== ASSET PATHS (upload to these exact locations) ======================
  const ASSETS = {
    bg: 'assets/backgrounds/courtroom.png',          // your 136×88 (or any) courtroom image
    sfx: 'assets/sfx/fart.wav',                       // short sound
    sprites: {
      judge: {
        idle: 'assets/characters/judge/judge_idle.png',           // 4 frames, 64×64
        walk: 'assets/characters/judge/judge_walk.png',           // 6 frames
        crouch_fart_left: 'assets/characters/judge/judge_fart_left.png' // 3 frames (right mirrored)
      },
      chimpNpcIdle: 'assets/characters/chimp_npc_idle.png',       // 4 frames, 64×64
      moleNpcIdle:  'assets/characters/mole_npc_idle.png'         // 4 frames, 64×64
    }
  };

  // ====== CANVAS / WORLD SETUP ==============================================
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // Render scale will be handled by CSS; canvas internal size uses background size.
  const FRAME_W = 64, FRAME_H = 64;          // sprite frame size (recommended)
  const SPEED = 0.5;                          // world units per ms (tuned for small bg)
  let   GROUND_Y = canvas.height - 6;         // bottom of background is the ground (adjusted once bg loads)
  const PROMPT_RADIUS = 14;                   // distance (in background pixels) to show prompt
  const FART_MS = 350;

  // ====== INPUT (touch) ======================================================
  const zones = {
    left:  document.querySelector('.zone.left'),
    right: document.querySelector('.zone.right')
  };
  const Hold = { left:false, right:false };
  const setHold = (side, v) => { Hold[side] = v; };
  const touchOn = (el, down) => {
    const start = (e)=>{ down(true); e.preventDefault(); };
    const end   = (e)=>{ down(false); e.preventDefault(); };
    el.addEventListener('touchstart', start, {passive:false});
    el.addEventListener('touchend',   end,   {passive:false});
    el.addEventListener('touchcancel',end,   {passive:false});
  };
  touchOn(zones.left,  v=>setHold('left',v));
  touchOn(zones.right, v=>setHold('right',v));

  // Tap on canvas to interact (we’ll detect NPC hit)
  canvas.addEventListener('touchstart', onTap, {passive:false});
  function onTap(e){
    const t = e.changedTouches[0];
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width  / rect.width;
    const scaleY = canvas.height / rect.height;
    const cx = (t.clientX - rect.left) * scaleX;
    const cy = (t.clientY - rect.top)  * scaleY;
    tryInteract(cx, cy);
    e.preventDefault();
  }

  // ====== LOADERS ============================================================
  function loadImage(src){ return new Promise(res=>{ const img=new Image(); img.onload=()=>res(img); img.onerror=()=>res(null); img.src=src; }); }
  function loadAudio(src){ try{ const a=new Audio(src); return a; }catch(_){ return null; } }

  const Images = { bg:null, judge:{idle:null,walk:null,fart:null}, chimp:null, mole:null };
  let fartAudio = loadAudio(ASSETS.sfx);

  (async function preload(){
    Images.bg = await loadImage(ASSETS.bg);
    if (Images.bg){
      // Resize canvas to background’s native resolution
      canvas.width  = Images.bg.naturalWidth  || Images.bg.width;
      canvas.height = Images.bg.naturalHeight || Images.bg.height;
      GROUND_Y = canvas.height - 1; // bottom scanline as ground
    }
    Images.judge.idle = await loadImage(ASSETS.sprites.judge.idle);
    Images.judge.walk = await loadImage(ASSETS.sprites.judge.walk);
    Images.judge.fart = await loadImage(ASSETS.sprites.judge.crouch_fart_left);
    Images.chimp      = await loadImage(ASSETS.sprites.chimpNpcIdle);
    Images.mole       = await loadImage(ASSETS.sprites.moleNpcIdle);
    requestAnimationFrame(loop);
  })();

  // ====== ENTITIES ===========================================================
  const player = { x: canvas.width/2, y: GROUND_Y, facing: 1, state:'idle', until:0, anim:0, w:FRAME_W, h:FRAME_H };
  const chimp  = { name:'chimp', x: Math.max(24, canvas.width*0.25), y:GROUND_Y, anim:0, w:FRAME_W, h:FRAME_H };
  const mole   = { name:'mole',  x: Math.min(canvas.width-24, canvas.width*0.75), y:GROUND_Y, anim:0, w:FRAME_W, h:FRAME_H };

  function distX(a,b){ return Math.abs(a.x - b.x); }
  function facingToward(from, to){ return (to.x < from.x) ? -1 : 1; }

  // ====== ANIMATION HELPERS ==================================================
  const FR = { judge:{ idle:4, walk:6, fart:3 }, npc:{ idle:4 } };
  function drawFrame(img, frames, tms, x, y, facing=1){
    if (!img) return false;
    const idx = Math.floor((tms/120) % frames);
    const sx = idx * FRAME_W;
    ctx.save();
    if (facing === -1){
      ctx.translate(x,0);
      ctx.scale(-1,1);
      x = 0;
    }
    ctx.drawImage(img, sx, 0, FRAME_W, FRAME_H, x - FRAME_W/2, y - FRAME_H, FRAME_W, FRAME_H);
    ctx.restore();
    return true;
  }

  // ====== GAME LOOP ==========================================================
  let last = 0;
  function loop(ts){
    const dt = (ts - last) || 16.67; last = ts;

    // Movement (hold to walk)
    if (player.state !== 'fart'){
      if (Hold.left && !Hold.right){ player.x -= SPEED*dt; player.facing = -1; player.state = 'walk'; }
      else if (Hold.right && !Hold.left){ player.x += SPEED*dt; player.facing = 1; player.state = 'walk'; }
      else { player.state = 'idle'; }
    }

    // Bounds (keep inside background)
    const margin = FRAME_W*0.4;
    player.x = Math.max(margin, Math.min(canvas.width - margin, player.x));

    // End fart
    if (player.state === 'fart' && performance.now() > player.until){ player.state = 'idle'; }

    // Advance anim clocks
    player.anim += dt; chimp.anim += dt; mole.anim += dt;

    // Render
    render();

    requestAnimationFrame(loop);
  }

  function render(){
    // Background (or placeholder)
    if (Images.bg) ctx.drawImage(Images.bg, 0, 0, canvas.width, canvas.height);
    else { ctx.fillStyle = '#1d1f29'; ctx.fillRect(0,0,canvas.width,canvas.height); }

    // Ground guideline (optional)
    // ctx.fillStyle = 'rgba(255,255,255,0.05)';
    // ctx.fillRect(0, GROUND_Y, canvas.width, 1);

    // NPCs
    drawNPC(chimp, Images.chimp, 'Chimp');
    drawNPC(mole,  Images.mole,  'Mole');

    // Player (sprites if present; else placeholder purple block + wig strip)
    if (Images.judge.walk || Images.judge.idle){
      if (player.state === 'walk') {
        drawFrame(Images.judge.walk || Images.judge.idle, Images.judge.walk ? FR.judge.walk : FR.judge.idle, player.anim, player.x, player.y, player.facing);
      } else if (player.state === 'fart' && Images.judge.fart){
        drawFrame(Images.judge.fart, FR.judge.fart, player.anim, player.x, player.y, player.facing);
      } else {
        drawFrame(Images.judge.idle || Images.judge.walk, Images.judge.idle ? FR.judge.idle : FR.judge.walk, player.anim, player.x, player.y, player.facing);
      }
    } else {
      // Placeholder
      ctx.fillStyle = '#8338EC'; // Social Burst purple
      ctx.fillRect(player.x - 22, player.y - 60, 44, 60);
      ctx.fillStyle = '#e7e7e7'; ctx.fillRect(player.x - 22, player.y - 66, 44, 6);
    }

    // Fart puff if farting (works even without fart sprite)
    if (player.state === 'fart'){
      const dir = player.facing;
      const cx = player.x + dir * 24;
      const cy = player.y - 16;
      ctx.beginPath();
      ctx.arc(cx, cy, 6 + Math.random()*4, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(173,255,47,0.9)';
      ctx.fill();
    }

    // Prompt if close to an NPC
    const target = closestInRange();
    if (target){
      drawPrompt(target.x, target.y - FRAME_H - 6, 'Tap character');
    }
  }

  function drawNPC(npc, img, label){
    if (img){
      drawFrame(img, FR.npc.idle, npc.anim, npc.x, npc.y, 1);
    } else {
      ctx.fillStyle = '#5ab'; // placeholder
      ctx.fillRect(npc.x - 22, npc.y - 48, 44, 48);
    }
    // name
    ctx.fillStyle = '#ddd'; ctx.font = '10px monospace'; ctx.textAlign = 'center';
    ctx.fillText(label, npc.x, npc.y - FRAME_H - 10);
  }

  function drawPrompt(x, y, text){
    const w = 86, h = 16;
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.fillRect(x - w/2, y - h, w, h);
    ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.strokeRect(x - w/2, y - h, w, h);
    ctx.fillStyle = '#111'; ctx.font = '10px monospace'; ctx.textAlign = 'center';
    ctx.fillText(text, x, y - 4);
  }

  function closestInRange(){
    const near = [];
    if (Math.abs(player.x - chimp.x) <= PROMPT_RADIUS) near.push(chimp);
    if (Math.abs(player.x - mole.x)  <= PROMPT_RADIUS) near.push(mole);
    if (!near.length) return null;
    return near.reduce((a,b)=> Math.abs(player.x-a.x) < Math.abs(player.x-b.x) ? a : b);
  }

  // ====== INTERACTION (tap to fart when close & tap hits NPC bounds) =========
  function tryInteract(cx, cy){
    const target = closestInRange();
    if (!target) return;

    // Hit test on NPC sprite bounds
    const halfW = FRAME_W/2, topY = target.y - FRAME_H, bottomY = target.y;
    const within =
      (cx >= target.x - halfW) && (cx <= target.x + halfW) &&
      (cy >= topY) && (cy <= bottomY);

    if (!within) return;

    // Trigger fart
    player.facing = facingToward(player, target);
    player.state = 'fart';
    player.until = performance.now() + FART_MS;
    player.anim = 0; // restart anim for the 3-frame fart sheet
    if (fartAudio){ try { fartAudio.currentTime = 0; fartAudio.play(); } catch(_){} }
    // (Optional future) make target flinch here
  }
  </script>
</body>
</html>
